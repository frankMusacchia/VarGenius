package LIB::programs_management;
## programs_management.pm
#Author: Francesco Musacchia  (2016)
#Permits the management of an input configuration file whose variables
#will be put inside an hash

use Exporter();

@ISA = qw(Exporter);
@EXPORT_OK = qw( initialize_folders checkConfigVariables checkVariable
                 configFile2Hash check_input_fasta_file
                 correct_type get_chosen_session hash2ConfigFile
                 try_exec_command try_exec_job print_and_log log_and_exit
                 execute_threads build_input_name_from_executed separate_input_ids
                 kill_job remove_analysis show_groups_from_analyses get_ped_file
                 sort_samples remove_groups clean_folders get_sorted_sample_names
                 store_groups R_die);
                 
use strict;
use warnings;
use Data::Dumper;#To print the hashes
use Cwd;#To change work directory
use Parallel::ForkManager;#For parallel executions
use File::Copy;#To manage files

#Using a library for database management
use LIB::db_management qw(get_id_if_exists_from_db db_remove_analysis 
													db_print_selected_rows update_table do_query_select_all );

use LIB::files_manipulation qw( list_to_array delete_file is_folder_empty extract_col_from_file 
																extract_name);

use LIB::files_management qw( );
			
			
			
=head2 get_chosen_session

 Title   : get_chosen_session
 Usage   : get_chosen_session( -workingFolder => 'the folder where you search'
                               );

 Function: Opens the working directory and gives to the user the possibility to choose one

 Returns : nothing

=cut
sub get_chosen_session {
        my $workingFolder = shift;

        my $chosenFolder = "";

        if ( !(is_folder_empty($workingFolder)) ){
                my $workDir = getcwd;
                chdir $workingFolder;
                (system("ls -d */")) == 0 or die "Unable to list directory $workingFolder!\n";
                print "Choose your folder: ";
                $chosenFolder = <STDIN>;
                chomp $chosenFolder;
               	$chosenFolder = $1 if($chosenFolder=~/(.*)\/$/);#Cut last letter if it is /
                #print $myFolder;
                #my $validSession = 0;
                #if (valid_session($myFolder) == 1){
                                #$validSession = 1;
                #}
                while ( !(-d $chosenFolder)){
                        (system("ls -d */")) == 0 or die "Unable to list directory $chosenFolder!\n";
                       	print "Choose your folder: ";
                       	$chosenFolder = <STDIN>;
                        chomp $chosenFolder;
                        $chosenFolder = $1 if ($chosenFolder=~/(.*)\/$/);#Cut last letter if it is /
                        #if (valid_session($myFolder) == 1){
                                #$validSession = 1;
                        #}
                }
                $chosenFolder =  $workingFolder."/".$chosenFolder;
                chdir $workDir;
        }else{
                print "There are not existing sessions in $workingFolder. Please restart the program and create a new one!\n";
                exit 1;
        }

        return $chosenFolder;
}


=head2 get_sorted_sample_names

 Title   : get_sorted_sample_names
 Usage   : get_sorted_sample_names( -database => 'name of the database,
                               );

 Function: Sorts the samples belonging to the given group_id

 Returns : returns an array with sample_names sorted as for the kinship given
						in the configuration file. Uses the function sort_samples

=cut
sub get_sorted_sample_names{
	my $cfg_hash = shift;
	my $group_id = shift;
	my $log_file = shift;
	
	my $query = "SELECT ".$cfg_hash->{'db_sample_name'}." FROM  ".$cfg_hash->{'db_sample_table'}." WHERE ".$cfg_hash->{'db_group_id'}."=$group_id;";	
	print_and_log( "Executing: $query\n",$log_file);
	my $group_sam = do_query_select_all($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},$cfg_hash->{'db_pass'},$query,$cfg_hash->{'db_sample_id'});


	#Getting the samples list associated to the groupid
	my $samples_h;#Samples hash to be reordered
	my @sort_samples = ();#The array with samples id reordered
	
	#Get the kinship, to make the resorting
	foreach my $sample_name (keys %{$group_sam}){
		#Obtain the kinship from the database given the sample id
		my $sample_id = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
														$cfg_hash->{'db_pass'},$cfg_hash->{'db_sample_table'},$cfg_hash->{'db_sample_id'},
														$cfg_hash->{'db_sample_name'},"'".$sample_name."'");	
		#Obtain the kinship from the database given the sample id
		my $kinship = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
														$cfg_hash->{'db_pass'},$cfg_hash->{'db_sample_table'},$cfg_hash->{'db_sample_kinship'},
													#	$cfg_hash->{'db_sample_id'},$sample_id);	
													$cfg_hash->{'db_sample_name'},"'".$sample_name."'");
		#Build an hash to reorder
		$samples_h->{$sample_name}->{'id'} = $sample_name;
		$samples_h->{$sample_name}->{'k'} = $kinship;
	}
	#Sort the samples as in samples_order parameter
	sort_samples($samples_h,$cfg_hash->{'samples_order'},\@sort_samples);
	
	return @sort_samples;
}
	
	
=head2 rank

 Title   : rank
 Usage   : rank(  );

 Function:  A function to make a comparison between elements using a
						order given in input
						
 Returns : returns the position of the element

=cut
sub rank {
	
	my $l = shift;
	my $s_order = shift;
	
	if ($l eq $s_order->[0]){return 0;}
	if ($l eq $s_order->[1]){return 1;}
	if ($l eq $s_order->[2]){return 2;}
	if ($l eq $s_order->[3]){return 3;}
	if ($l eq $s_order->[4]){return 4;}

}

=head2 sort_samples

 Title   : sort_samples
 Usage   : sort_samples(  );

 Function:  This subroutine takes in input an hash with sample information
						$s->{sample_id}->{name} and $s->{sample_id}->{kinship}
						then sorts the samples based on the kinship order in 
						program_config, parameter samples_order
					
						Exploits the function rank to sort based on the given order
						
 Returns : writes in an array given in input the samples ids sorted (or names if names are given)

=cut
sub sort_samples{
	my $samples = shift;
	my $order = shift;
	my $sort_samples = shift;
		
	my @s_order = split(",",$order);	
	
 foreach my $key ( #
  sort  { rank($samples->{$a}->{'k'},\@s_order) <=> rank( $samples->{$b}->{'k'},\@s_order) }
        keys %{$samples})
 {
        #print $samples->{$key}->{'n'}."\n";
        push(@$sort_samples,$samples->{$key}->{'id'});
 }
}

=head2 clean_folders

 Title   : clean_folders
 Usage   : clean_folders(  );

 Function: Clean the folders of the groups given in input
						- Remove all SAM files generated by BWA
						- Remove all bam files not sorted and not indexed
						- Remove all fastq useless files
						- Remove all the content of the refine, varcall and genotype folders
 Returns : 

=cut
sub clean_folders{
	my $cfg_hash = shift;
	my $group_ids = shift;
	my $work_folder = shift;
	my $log_file = shift;
	
	#my @group_ids = split(",",$groups_l);
	#foreach my $group_id (@$group_ids){
	
	for ( my $i = 0; $i < scalar(@$group_ids); $i++){
		#Obtain the group name from the database given the group id
		my $group_name = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
														$cfg_hash->{'db_pass'},$cfg_hash->{'db_groups_table'},$cfg_hash->{'db_group_name'},
														$cfg_hash->{'db_group_id'},$group_ids->[$i]);

		my $outFolder = $work_folder."/$group_name/".$cfg_hash->{'align_out_f'};					
		print_and_log("\n\n#########Cleaning folder $outFolder for group ".$group_ids->[$i].":  ..\n",$log_file);
							
		#if (!is_folder_empty($outFolder)){print "Removing from $outFolder..\n";}#DEBUGCODE
		
		#Remove all SAM files generated by BWA
		print_and_log("Removing all SAM files from $outFolder:".$outFolder."/*.".$cfg_hash->{'sam_ext'}."...\n",$log_file);
		delete_file($outFolder."/*.".$cfg_hash->{'sam_ext'});
		
		#Remove all bam files not sorted and not indexed
		print_and_log("Removing all bam files not sorted and not indexed from $outFolder:".
			      $outFolder."/*_".$cfg_hash->{'align_step'}."_".$cfg_hash->{'mark_rem_dup_step'}.".".$cfg_hash->{'bam_ext'}.
			      "...\n",$log_file);
		delete_file($outFolder."/*_".$cfg_hash->{'align_step'}."_".$cfg_hash->{'mark_rem_dup_step'}.".".$cfg_hash->{'bam_ext'});
		#Remove all bam files obtained on read files by lane
		print_and_log("Removing all bam files obtained from lanes from $outFolder:".
			      $outFolder."/*_L00*.".$cfg_hash->{'bam_ext'}."...\n",$log_file);
		delete_file($outFolder."/*_L00*.".$cfg_hash->{'bam_ext'});
		
		#Remove all fastq useless files
		print_and_log("Removing all fastq useless files from $outFolder:".
			      $outFolder."/*_".$cfg_hash->{'mergepe_step'}.".".$cfg_hash->{'fastq_ext'}.
			      "...\n",$log_file);
		delete_file($outFolder."/*_".$cfg_hash->{'mergepe_step'}.".".$cfg_hash->{'fastq_ext'});
		
		#Refine folder
		$outFolder = $work_folder."/$group_name/".$cfg_hash->{'refine_out_f'};
		#Remove all the content of the refine folder
		print_and_log("Removing all the content of the folder: $outFolder\n",$log_file);
		delete_file($outFolder."/*");
		
		#varcall folder
		$outFolder = $work_folder."/$group_name/".$cfg_hash->{'varcall_out_f'};
		#Remove all the content of the varcall_out folder
		print_and_log("Removing all the content of the folder: $outFolder\n",$log_file);
		delete_file($outFolder."/*");

		#genotype folder
		$outFolder = $work_folder."/$group_name/".$cfg_hash->{'genot_out_f'};
		#Remove all the content of the genotype folder
		print_and_log("Removing all the content of the folder: $outFolder\n",$log_file);
		delete_file($outFolder."/*");
	
		print_and_log("#########$work_folder/$group_name/ cleaned!\n\n",$log_file);
	}
}


=head2 get_ped_file

 Title   : get_ped_file
 Usage   : get_ped_file(  );

 Function:  returns 1 if the analysis identifier given in input is a trio.
						To check this accesses the database and looks if there are 
						three samples and there are M,F and P (Mother, Father and Proband)
						
 Returns : 1 if is a trio, 0 otherwise

=cut
sub get_ped_file{
	my $cfg_hash = shift;
	my $group_id = shift;
	my $log_file = shift;
		
	my $ret_val = 0;
	my $sep = "\t";
	#Get the samples ids involved for the group
	my $query = "SELECT ".$cfg_hash->{'db_sample_id'}." FROM  ".$cfg_hash->{'db_sample_table'}." WHERE ".
							$cfg_hash->{'db_group_id'}."=$group_id;";	
	#print_and_log( "Executing: $query\n",$log_file);
	my $group_sam = do_query_select_all($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},$cfg_hash->{'db_pass'},$query,$cfg_hash->{'db_sample_id'});
	
	my $num_samples = scalar(keys %{$group_sam});
	my @kinships = ();
	#The pedfile is created if there are only three samples (Mother father and proband)
	if( $num_samples == 3){
		my $moth_name = "";
		my $fath_name  ="";
		my $prob_name  ="";
		my $gender_id = -1;
		
		#Print the header for information about the genotype for the sample
		foreach my $sample_id (keys %{$group_sam}){
			#Obtain the kinship
			my $kinship = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
														$cfg_hash->{'db_pass'},$cfg_hash->{'db_sample_table'},$cfg_hash->{'db_sample_kinship'}
														,$cfg_hash->{'db_sample_id'},$sample_id);
			
			if (defined $kinship){
				#Found the father!
				if( $kinship eq 'F' ){
					#Getting the sample name
					$fath_name  = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
												$cfg_hash->{'db_pass'},$cfg_hash->{'db_sample_table'},$cfg_hash->{'db_sample_name'}
												,$cfg_hash->{'db_sample_id'},$sample_id);		
					push(@kinships,$kinship);
				}
				#Found the mother!
				if( $kinship eq 'M' ){
					#Getting the sample name
					$moth_name  = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
												$cfg_hash->{'db_pass'},$cfg_hash->{'db_sample_table'},$cfg_hash->{'db_sample_name'}
												,$cfg_hash->{'db_sample_id'},$sample_id);						
					push(@kinships,$kinship);
				}
				#Found a proband!
				if( $kinship eq 'P' ){
					#Getting the sample name
					$prob_name  = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
												$cfg_hash->{'db_pass'},$cfg_hash->{'db_sample_table'},$cfg_hash->{'db_sample_name'}
												,$cfg_hash->{'db_sample_id'},$sample_id);
					push(@kinships,$kinship);
					my $gender = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
																$cfg_hash->{'db_pass'},$cfg_hash->{'db_sample_table'},$cfg_hash->{'db_sample_gender'}
																,$cfg_hash->{'db_sample_id'},$sample_id);
					if (defined $gender){
						if ($gender eq 'M'){ $gender_id = 1;}else{$gender_id = 2;}
					}
				}				
			}else{
				print_and_log("Kinship is not defined for sample $sample_id..\n",$log_file);
			}

		}
		#If all F,M and P have been found...
		if ( (grep {/\bF\b/} @kinships ) and (grep {/\bM\b/} @kinships ) and (grep {/\bP\b/} @kinships )){
			print_and_log("Found Mother, father and proband. I will do a pedfile..\n",$log_file);
			$ret_val = 1;
			
			#Obtain the group name from the database given the group id
			my $group_name = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
															$cfg_hash->{'db_pass'},$cfg_hash->{'db_groups_table'},$cfg_hash->{'db_group_name'}
															,$cfg_hash->{'db_group_id'},$group_id);

			#Set the path of the file
			my $out_ped = $cfg_hash->{$group_id."_data_fold"}."/$group_name.".$cfg_hash->{'ped_ext'};
			#Print the three lines of the file
			open(PED_F,">".$out_ped) or die "Cannot open file $out_ped\n";
			
			print PED_F $group_name.$sep.$fath_name.$sep."0".$sep."0".$sep."1".$sep."1\n";
			print PED_F $group_name.$sep.$moth_name.$sep."0".$sep."0".$sep."2".$sep."1\n";
			print PED_F $group_name.$sep.$prob_name.$sep.$fath_name.$sep.$moth_name.$sep.$gender_id.$sep."2";
			close(PED_F);
			
			print_and_log("Pedfile written at: $out_ped\n",$log_file);
			#Add pedfile name in the database
			#UPDATE fields = values
			my $fields = $cfg_hash->{'db_pedfile'};
			my $values = "'".$group_name.".".$cfg_hash->{'ped_ext'}."'";
			#WHERE 
			my $fields2 = $cfg_hash->{'db_group_id'};
			my $values2 = $group_id;

			#Update
			update_table($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
					$cfg_hash->{'db_pass'},$cfg_hash->{'db_groups_table'},$fields,$values,$fields2,$values2);
			print_and_log("Updated table ".$cfg_hash->{'db_groups_table'}." with the pedfile name\n",$log_file);
		}
	}
	return $ret_val;
}


=head2 remove_analysis

 Title   : remove_analysis
 Usage   : remove_analysis(  );

 Function:  removes an analysis from the database given a list of analysis ids
						or given a list of sample sheet names
						
 Returns : nothing

=cut
sub remove_analysis{
	my $cfg_hash = shift;
	my $log_file = shift;
	my $anal_to_rem = shift;
	
	print_and_log("Removing an analysis from the database..\n",$log_file);
	my $sep = $cfg_hash->{'parameters_sep'};


	#If a string has given in input..
	if ( !correct_type($anal_to_rem,"positiveint") ){
		#Obtain the group name from the database given the group id
		my $anal_to_del = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
										$cfg_hash->{'db_pass'},$cfg_hash->{'db_analysis_table'},$cfg_hash->{'db_analysis_id'}
										,$cfg_hash->{'db_analysis_name'},"'".$anal_to_rem."'");
		if ( correct_type($anal_to_del,"positiveint") ){
			print_and_log("Removing analysis $anal_to_del from database:\n",$log_file);
			db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
									$cfg_hash->{'db_pass'},$cfg_hash->{'db_readf_table'},$cfg_hash->{'db_analysis_id'},$anal_to_del);
			print_and_log($cfg_hash->{'db_readf_table'}."...",$log_file);					
			db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
									$cfg_hash->{'db_pass'},$cfg_hash->{'db_sample_table'},$cfg_hash->{'db_analysis_id'},$anal_to_del);
			print_and_log($cfg_hash->{'db_sample_table'}."...",$log_file);
			db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
									$cfg_hash->{'db_pass'},$cfg_hash->{'db_groups_table'},$cfg_hash->{'db_analysis_id'},$anal_to_del);
			print_and_log($cfg_hash->{'db_groups_table'}."...",$log_file);
			db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
									$cfg_hash->{'db_pass'},$cfg_hash->{'db_analysis_table'},$cfg_hash->{'db_analysis_id'},$anal_to_del);
			print_and_log($cfg_hash->{'db_analysis_table'}."...\n",$log_file);
		}else{print_and_log("Analysis $anal_to_del is not present in db ".$cfg_hash->{'db_name'}."\n",$log_file);}
	}else{
		my @anals_to_del = split($sep,separate_input_ids($anal_to_rem,$sep));
		foreach my $anal_to_del (@anals_to_del){
			#If the parameter is a number then use db_analysis_id, otherwise db_analysis_name

			if ( correct_type($anal_to_del,"positiveint") ){					
				print_and_log("Removing analysis $anal_to_del from database:\n",$log_file);
				db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
										$cfg_hash->{'db_pass'},$cfg_hash->{'db_readf_table'},$cfg_hash->{'db_analysis_id'},$anal_to_del);
				print_and_log($cfg_hash->{'db_readf_table'}."...",$log_file);					
				db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
										$cfg_hash->{'db_pass'},$cfg_hash->{'db_sample_table'},$cfg_hash->{'db_analysis_id'},$anal_to_del);
				print_and_log($cfg_hash->{'db_sample_table'}."...",$log_file);
				db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
										$cfg_hash->{'db_pass'},$cfg_hash->{'db_groups_table'},$cfg_hash->{'db_analysis_id'},$anal_to_del);
				print_and_log($cfg_hash->{'db_groups_table'}."...",$log_file);
				db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
										$cfg_hash->{'db_pass'},$cfg_hash->{'db_analysis_table'},$cfg_hash->{'db_analysis_id'},$anal_to_del);
				print_and_log($cfg_hash->{'db_analysis_table'}."...\n",$log_file);
			}else{print_and_log("Analysis $anal_to_del is not present in db ".$cfg_hash->{'db_name'}."\n",$log_file);}
		}
	}
}

=head2 store_groups

 Title   : store_groups
 Usage   : store_groups(  );

 Function:  Given a set of group ids moves all the output files needed into a folder named
					as the groupname. 
					The files to move will be picked from the outfile_list file in the DATA folder
					The files moved will be substituted with symbolik links using the 'ln -s' command
						
 Returns : nothing

=cut
sub store_groups{
	my $cfg_hash = shift;
	my $working_folder = shift;
	my $grs_to_store_str = shift;
	my $log_file = shift;	
	
	my $storage_dir = $cfg_hash->{'storage_f'};
	print_and_log("Storing files for the analysis into $storage_dir..\n",$log_file);
	#Get an array of group ids to store
	my $sep = $cfg_hash->{'parameters_sep'};
	my @grs_to_store = split($sep,separate_input_ids($grs_to_store_str,$sep));

	#Execute for each group id to store	 	
	foreach my $group_id (@grs_to_store){
		
		#If the parameter is a number then proceed
		if ( correct_type($group_id,"positiveint") ){					
			
			#Obtain the group name from the database given the group id
			my $group_name = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
																			$cfg_hash->{'db_pass'},$cfg_hash->{'db_groups_table'},$cfg_hash->{'db_group_name'}
																			,$cfg_hash->{'db_group_id'},$group_id);											
			#Create a directory for the group into the storage dir
			my $group_fold_st = $storage_dir."/".$group_name;
			#Check if directory exists, otherwise creates it
			if (! (-d $group_fold_st) ){

								
				#Get the paths from the outlist file
				my $outlist_f = $working_folder."/".$group_name."/".$cfg_hash->{'data_fold'}."/".$group_name."_".$cfg_hash->{'outlist_file'};
				print_and_log("Getting the paths to move from $outlist_f..\n",$log_file);
				my $only_paths_f = $outlist_f.".onlypaths";
				extract_col_from_file($outlist_f,$cfg_hash->{'outlist_path_pos'},$only_paths_f);
				my @paths = list_to_array($only_paths_f,'NO_NEW_LINE');

				#Create a new folder
				print_and_log("Creating folder $group_fold_st...\n",$log_file);
				mkdir $group_fold_st or die "ERROR: can't create folder $group_fold_st. Check permissions. \n";
								
				#For each file path into the outlist file... 
				foreach my $path ( @paths ){
					print_and_log("Moving $path to  $group_fold_st..\n",$log_file);
					#Move the file into the storage directory
					move($path,$group_fold_st) or print "ERROR: unable to move $path in $group_fold_st\n";
					
					#delete_file($tempFile);
					#Create a symbolink link using the old name to the current path	
					my $file_name = extract_name($path,0);
					print_and_log("Creating symbolic link $group_fold_st/$file_name..\n",$log_file);
					symlink $group_fold_st."/".$file_name, $path;
				}
				##################################################
				## UPDATE STORAGE STATUS
				##################################################
				
				#Update the group table with the fact that the analysis was stored (stored=1). 
				my $stored = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
									$cfg_hash->{'db_pass'},$cfg_hash->{'db_groups_table'},$cfg_hash->{'db_group_status'}
									,$cfg_hash->{'db_group_id'},$group_id);

					my $fields = $cfg_hash->{'db_group_stored'};
					my $values = 1;
					my $fields2 = $cfg_hash->{'db_group_id'};
					my $values2 = $group_id;
					update_table($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
											$cfg_hash->{'db_pass'},$cfg_hash->{'db_groups_table'},$fields,$values,$fields2,$values2);			
				##################################################		
					
			}else{print_and_log("WARNING: The folder $group_fold_st already exists. Check if the transfer has already done...\n",$log_file);}
		}else{print_and_log("Group $group_id is not a db id\n",$log_file);}
	}
}	
	
=head2 remove_groups

 Title   : remove_groups
 Usage   : remove_groups(  );

 Function:  removes an analysis from the database given a list of group ids
						
 Returns : nothing

=cut
sub remove_groups{
	my $cfg_hash = shift;
	my $log_file = shift;
	my $gr_to_rem = shift;
	
	print_and_log("Removing a group from the database..\n",$log_file);
	my $sep = $cfg_hash->{'parameters_sep'};
	my @grs_to_del = split($sep,separate_input_ids($gr_to_rem,$sep));

	foreach my $gr_to_del (@grs_to_del){
		#If the parameter is a number then proceed
		if ( correct_type($gr_to_del,"positiveint") ){					
			#Obtain the group name from the database given the group id
			my $group_name = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
																			$cfg_hash->{'db_pass'},$cfg_hash->{'db_groups_table'},$cfg_hash->{'db_group_name'}
																			,$cfg_hash->{'db_group_id'},$gr_to_del);
			#Obtain the run id from the database given the group id
			my $analysis_id = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
																			$cfg_hash->{'db_pass'},$cfg_hash->{'db_groups_table'},$cfg_hash->{'db_analysis_id'}
																			,$cfg_hash->{'db_group_id'},$gr_to_del);
											
			print_and_log("Removing analysis $group_name from database (id: $gr_to_del):\n",$log_file);
			db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
									$cfg_hash->{'db_pass'},$cfg_hash->{'db_genotype_sample_table'},$cfg_hash->{'db_group_id'},$gr_to_del);
			print_and_log($cfg_hash->{'db_genotype_sample_table'}."...",$log_file);
			db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
									$cfg_hash->{'db_pass'},$cfg_hash->{'db_var_statistics_table'},$cfg_hash->{'db_group_id'},$gr_to_del);
			print_and_log($cfg_hash->{'db_var_statistics_table'}."...\n",$log_file);
			db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
									$cfg_hash->{'db_pass'},$cfg_hash->{'db_readf_table'},$cfg_hash->{'db_group_id'},$gr_to_del);
			print_and_log($cfg_hash->{'db_readf_table'}."...",$log_file);					
			db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
									$cfg_hash->{'db_pass'},$cfg_hash->{'db_sample_table'},$cfg_hash->{'db_group_id'},$gr_to_del);
			print_and_log($cfg_hash->{'db_sample_table'}."...",$log_file);
			db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
									$cfg_hash->{'db_pass'},$cfg_hash->{'db_groups_table'},$cfg_hash->{'db_group_id'},$gr_to_del);
			print_and_log($cfg_hash->{'db_groups_table'}."...",$log_file);

			
			#If the run was only from this analysis remove also the sample_sheet name
			#Get the group ids involved for the analysis
			my $query = "SELECT ".$cfg_hash->{'db_group_id'}." FROM  ".$cfg_hash->{'db_groups_table'}." WHERE ".
									$cfg_hash->{'db_analysis_id'}."=$analysis_id;";	
			print_and_log( "Executing: $query\n",$log_file);
			my $group_ids = do_query_select_all($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},$cfg_hash->{'db_pass'},$query,$cfg_hash->{'db_group_id'});
			
			my $num_groups = scalar(keys %{$group_ids});
			if ( $num_groups == 0){
				print_and_log("Last group for analysis id $analysis_id. Removing from ".$cfg_hash->{'db_analysis_table'}."...\n",$log_file);				
				db_remove_analysis($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
										$cfg_hash->{'db_pass'},$cfg_hash->{'db_analysis_table'},$cfg_hash->{'db_analysis_id'},$analysis_id);
			}
		}else{print_and_log("Group $gr_to_del is not present in db ".$cfg_hash->{'db_name'}."\n",$log_file);}
	}
}

=head2 show_groups_from_analyses

 Title   : show_groups_from_analyses
 Usage   : show_groups_from_analyses(  );

 Function:  shows groups related to a specific analysis name
						
 Returns : nothing

=cut
sub show_groups_from_analyses{
	my $cfg_hash = shift;
	my $log_file = shift;
	my $analysis_id = shift;
	
	print_and_log("Showing groups from analysis $analysis_id..\n",$log_file);
	my @res = ();

	if ( !correct_type($analysis_id,"positiveint") ){
		#Obtain the group name from the database given the group id
		$analysis_id = get_id_if_exists_from_db($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
								$cfg_hash->{'db_pass'},$cfg_hash->{'db_analysis_table'},$cfg_hash->{'db_analysis_id'}
								,$cfg_hash->{'db_analysis_name'},"'".$analysis_id."'");
	}
	my $fields = $cfg_hash->{'db_group_id'}.",".$cfg_hash->{'db_group_name'};
	
	if ( correct_type($analysis_id,"positiveint") ){
		#Prints the selected fields of the groups table using the analysis id as a key value
		db_print_selected_rows($cfg_hash->{'db_name'},$cfg_hash->{'db_dsn'},$cfg_hash->{'db_user'},
									$cfg_hash->{'db_pass'},$fields,$cfg_hash->{'db_groups_table'},
									$cfg_hash->{'db_analysis_id'},$analysis_id);
	}else{
		log_and_exit("ERROR: Cannot find any analysis with your input ...\n",$log_file);	
	}
}

=head2 initialize_folders

 Title   : initialize_folders
 Usage   : initialize_folders(  );

 Function:  this subroutine initializes the basic folders. If the folders.txt file is not present
            means that the program has not been installed in the folder used.
 Returns : nothing

=cut
sub initialize_folders{
  my $foldersFile = shift;

	#print "Opening $foldersFile..\n";
  #If the file with folders references is installed the program can start
  open (FOLD, $foldersFile) or die " ERROR: opening $foldersFile. Please install the program before.\n";
  my $line = <FOLD>;

	#print "Extracting folders path..\n";
  #Extracts folders paths
  my @folders = split(" ", $line);

  #The working folder is the first path
  my $workingFolder = $folders[0];

  #Cancel the final slash..if it is there it is removed
  if($workingFolder =~ /\/$/){
    chop($workingFolder);
  }

  my $programFolder = $folders[1];
  #Cancel the final slash..if it is there it is removed
  if($programFolder =~ /\/$/){
    chop($programFolder);
  }
  close(FOLD);

  return $workingFolder,$programFolder;
}

=head2 checkConfigVariables

 Title   : checkConfigVariables
 Usage   : checkConfigVariables( - configFile -> file with the user configuration
                              - variablesFile -> the path to a file with all variables written
                              - lineToCheck -> line in the variables file to be used
          );

 Function: this subroutine reads the config files and check if all variables are there and are well written.
            The variables.txt file is needed fot this operation.

 Returns : nothing

=cut
sub checkConfigVariables {
  my $configFile = shift;
  my $variablesFile = shift;
  my $lineToCheck = shift;

  my $hashToCheck;

  if (! open(VARF,"<$variablesFile")){ die "ERROR: Failure opening '$variablesFile'. Your program version is corrupted - $!";}
  if (! open(CFILE,"<$configFile")){ die "ERROR: Cannot find '$configFile' - Your program version is corrupted - $!";}

  #Stores the variables in the config user file inside the hash
  my $start = 0;
  while (my $line = <CFILE>){
    #This code is to jump to the line where there are some ###
    if ($line =~ /#########/){
      $start = 1;
    }
    #Put variables in a hash
    if( ($line =~ /(\S+)\s*=/) and ($start == 1) and !($line =~ /#/) ){
     #annoPrint ($line."\n");#DEBUGCODE
     $hashToCheck->{$1} = "OK";
    }
  }
  close(CFILE);

  my @confVars = ();

  #Variables that are in the configuration file must be also in the variables.txt file
  my $errors=0;
  my $lines=0;
  #For each line of the variables file
  while (my $line = <VARF>){
    $line =~ s/\n//;#Remove \n in the end of the line

    #get the variables in the line
    my @variables = split (/;/,$line);

    $lines++;
    #For each of the variables in the variables file
    foreach my $var (@variables){
      if ($lines == $lineToCheck){
        #print "program Variable: $var - - value: ".$hashToCheck->{$var}."\n";#DEBUGCODE
        #put the variable inside an array for program config
        push (@confVars, $var);
        if( !(defined($hashToCheck->{$var})) ){

          die "ERROR: in $configFile variable $var is missing. Please check the file. Closing...\n ";
          $errors=1;
        }#else{ annoPrint ("From the hash: ".$hashCheck->{$var}."\n";)}
      }
    }
  }

  #print_array(\@allVars);
  #print Dumper\$hashCheck;
  #Now check if all the elements in the hash are also in the array
  foreach my $key (keys %$hashToCheck){
     # print "Search $key in array...\n";#DEBUGCODE
     if (!(grep {/$key/} @confVars )){
       die "ERROR: Variable $key is in the config files and not in $variablesFile file. This is completely wrong. Program will not work...\n ";
     }
  }
  #if ($errors == 0){annoPrint ("ok";}
  close(VARF);
}

#=head2 store_parameters
 #Title   : store_parameters
 #Usage   : store_parameters(   );

 #Function:  Parses the arguments specified upon the command line.
 #Returns : nothing

#=cut
#sub store_parameters{
  #my $paramFile = shift;

  #my $defaultOK = 0;

  #print "Storing parameters...\n";
  #open (PARAM_FILE,"<$paramFile") or die "Cannot open $paramFile\n";

  #while ( my $line = <PARAM_FILE>){
    ##print $line;
    #chomp($line);#Remove the \n symbol

    ##Read the paths to all programs
    #if ( $line =~ /Programs paths/){
      #print "Reading program paths..\n";
      #$line = <PARAM_FILE>;
      #chomp($line);#Remove the \n symbol
      #while ($line !~ /#############/){
        ##print "Executing for $line..\n";
        #my @els = split("=", $line);#split the line using the = symbol
        #$els[0] =~ s/\s//;#remove any useless space
        #$els[1] =~ s/\s//;#remove any useless space
          #if (is_in_array($els[0],\@allowedPrograms)){
            #$programPaths->{$els[0]} = $els[1];
          #}
        #$line = <PARAM_FILE>;
        #chomp($line);#Remove the \n symbol
       	##print $line."\n";
      #}
    ##print Dumper\$programPaths;
    #}
    #$defaultOK = 0;
    ##print $line;
    ##Read the paths to all programs
    #if ( is_in_array($line,\@allowedPrograms) == 1){
      #my $program =  $line;
      #$line = <PARAM_FILE>;
      #chomp($line);#Remove the \n symbol
      #while ($line !~ /#############/){

        #my @els = split("=", $line);#split the line using the = symbol
        ##print scalar(@els)."\n";
        #if ( scalar(@els) > 1 ){
          #$els[0] =~ s/\s//;#remove any useless space
          ##print "sample: $els[0] - params: $els[1]\n";
          ##if (is_in_array($els[0],\@samplesNames)){
            #$programsParameters->{$program}->{$els[0]} = $els[1];
            #if (!$defaultOK){
              #$programsParameters->{$program}->{'def'} = $els[1];
            #}
          ##}
        #}else{
            #print "At least a string of parameters should be chosen for the samples for program $program\n";
            #exit;
        #}
        #$line = <PARAM_FILE>;
        #chomp($line);#Remove the \n symbol
      #}

    #}
  #}
  ##print Dumper\$programsParameters;
  #close(PARAM_FILE);
#}

=head2 configFile2Hash

 Title   : configFile2Hash
 Usage   : configFile2Hash( - configFilePath = path of the config file
                             - configHash = the pointer to the hash to be filled
                               );

 Function:  gets the hash table with all the path and names in input from the config file in input
 Returns : nothing

=cut
sub configFile2Hash{
  my $configFilePath=shift;
  my ($configHash) = shift;

  my $start = 0;
  #Here we open config file and read all its line to find elements belonging to each of the executers
  open (configFile,$configFilePath) or die "ERROR: The file $configFilePath doesn't exists. The program will exit..\n";
  while (my $line = <configFile>){
		#This IF is useful if you want to put a description above in the text file. Delimit it with a set of hashtags
    if ($line =~ /#########/){
      $start = 1;
    }
   # if( ($line =~ /(\S+)\s*=\s*(.+)/) and ($start == 1) and !($line =~ /#/) ){
   if( ($line =~ /(\w+)\s*=\s*(.+)/) and ($start == 1) and !($line =~ /^#/) ){
      if ( $2 ne ''){
			  $$configHash->{$1} = $2;
				#annoPrint ("$1 = $2\n") ;#DEBUGCODE
			}
    #}elsif ( $line =~ /(\S+)\s*=/ ){
    }elsif ( $line =~ /(\w+)\s*=/ ){
			delete($$configHash->{$1});	
		}
  }
  close(configFile);
  #print Dumper\$configHash; #DEBUGCODE
}


=head2 hash2ConfigFile

 Title   : hash2ConfigFile
 Usage   : hash2ConfigFile( - configFilePath = path of the config file
                             - configHash = the pointer to the hash to be filled
                               );

 Function: puts variables from an hash inside a file to make a configuration file
 Returns : nothing
=cut
sub hash2ConfigFile{
  my $configFilePath=shift;
  my ($configHash) = shift;
  my $start_string = "################\n";
  my $start = 0;

  #Here we open config file and read all its line to find elements belonging to each of the executers
  open (configFile,">$configFilePath") or die "ERROR: The file $configFilePath doesn't exists. The program will exit..\n";
  print configFile $start_string;
  foreach my $key ( keys %{$$configHash}){
    print configFile "$key = ".$$configHash->{$key}."\n";
  }
  close(configFile);
        #print Dumper\$configHash; #DEBUGCODE
}


=head2 checkVariable

 Title   : checkVariable
 Usage   : checkVariable(  - var -> value of the variable to check
                           - name -> name of the variable
                           - sentence -> something to write to the user in case of error)

 Function:  this subroutine checks if a variable has the YES or NO value. Dies otherwise.

 Returns : nothing

=cut
sub checkVariable {
  my $var = shift;
  my $name = shift;
  my $yesSentence = shift;
  my $noSentence = shift;

  my $no = '';
  if (defined $noSentence){
      $no = $noSentence;
  }
  if ( ($var ne 'YES') and ($var ne 'NO')){
    die "ERROR: Check variable $name in the config file. $var is a wrong value!\n";
  }elsif ($var eq 'YES'){
    print $yesSentence;
  }elsif ($var eq 'NO'){
    print $no;
  }
}


=head2 correct_type
Title  : correct_type
 Usage  : correct_type( -number => 'a number to check',
                      -typeWanted => 'the expected type');

 Function:       Check if the number is of the type given in input

  Returns 1 if true

=cut
sub correct_type {
  my $number = shift;
  my $typeWanted = shift;

  my $type = "";
  my $ret = 0;

  if ($typeWanted eq "positiveint"){
    #contains onli digits
    if ( $number =~ m/^\d+$/) {
      $ret=1;
    }
  }elsif ($typeWanted eq "real"){
    #Contains digits starting with (+-), separated by '.' and can be added the 'E-x'
    if ( $number =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/ ){
        $ret=1;
    }
  }
  return $ret;
}

=head2 check_input_fasta_file

 Title   : check_input_fasta_file
 Usage   : check_input_fasta_file(  - fastaSeqs = the name of the fasta
                                                                                                                                       $
                                                                                                                                       $
                                                                                                                                       $
                                                                                                                                       $
                               );

 Function:   check if the query FASTA file is well written and is in the working folder. Behaviour of the function is different
          if user is calling a saved session. The file is moved soon in the session folder.


 Returns : In the config hash will be returned:
                                               	- $$configHash->{$name.'Present'} => YES if the file is ok, NO otherwise
                                                - $$configHash->{$name.'Alphabet'} => alphabet type
                                                - $$configHash->{$name.'totSequences'} => total number of sequences in the file

=cut
sub check_input_fasta_file {

#CONTROLS IF THE QUERY EXISTS AND THE NAME IS .fa or .fasta
  my $fastaSeqs = shift;
  my ($configHash) = shift;#An hash with variables to be used in the main program
  my $newSession = shift;#Indicates if the session is loaded
  my $workingFolder = shift;#The folder where the user is working
  my $sessionFolder = shift;#The folder used for the output

  my $name = '';

  #The name has to be without dots inside. Only one dot can separate the extension from the name
  my $dots=0;
  my @line = split (//,$fastaSeqs);
  foreach my $char(@line){
      if ($char eq '.'){
          $dots++;
      }
  }
  if ($dots>1){
      die "Please change the name of your file removing all internal dots (not the one used for the extension). Exiting...\n";
  }
                                                                                                                                        
  #annoPrint ("Fasta name read: ".$fastaSeqs."\n";
  my @name = split(/\./,$fastaSeqs);
  #annoPrint ("Fasta name read: ".$name[0]."\n";
  #Here is created the name to use for all the files of output by extracting it from the fasta file name
  #It cannot be longer than 50 chars
  if (@name > 1){
    #$$configHash->{'name'} = extract_name($$configHash->{'sessionFolder'},0);
    $name = $name[0];
    #Checks for permitted characters
    if ( (length($name) > 50) # or !($$configHash->{'fastaSeqs'} =~ /(\.fasta?)|(\.fa?)/)
            or ($fastaSeqs !~ /^[A-za-z0-9\_\-]+\.(fa|fasta)$/i)){
            die "$fastaSeqs is not a correct FASTA file name. Allowed characters [A-Z,a-z,0-9,_,-]. Allowed extensions [.fasta,.fa]. Max length: 50 chars\n";
    }else{
      #If session is a new one
      #Fasta file must stay only in the working folder and it will be shifted. If it is not there,then only db creation can be done or $
      if ( $newSession == 1 ){
       my $fastaPath = $workingFolder.'/'.$fastaSeqs;
       print "Path to control for fasta: $fastaPath\n";
        #The Sequences file can also stay already in the session folder created by the user in a previous execution
        if (-e $fastaPath) {
          print "Sequences found in your working folder. Checking...\n";
          #After the name all the fasta is checked to see if it respects the standards
                                        my $warnings = checkFastaFormat($fastaPath,$$configHash->{'maxFastaSeqLen'},$$configHash->{'nuclIUPAC'},$$configHash->{'protIUPAC'});
                                        if($warnings > 0){
                                               	annoDie("Fasta check failed! The transcriptome you are using have the listed problems ".
                                                " which can cause stochastic error in BLAST programs execution. ".
                                                "Please try to correct the problems. Exiting...\n");
                                       }
          print "Copying the fasta in session folder...\n";
          #move($fastaPath,$sessionFolder);
          copy($fastaPath,$sessionFolder) or annoDie("Cannot copy $fastaPath in $sessionFolder");
          $$configHash->{$name.'Present'} = 'YES';
        }#else{
          ##This else happens when sequences file is not there. Then, if the user chose to execute analysis or to print output
          ## the program has to die.
          #if ( ($$configHash->{'doExecutePrograms'} eq 'YES') or ($$configHash->{'doBuildOutput'} eq 'YES')
            #or ($$configHash->{'extractStatistics'} eq 'YES')){
              #die "No sequences file found in $fastaPath. You'll cannot execute analysis...\n";
            #}
          #print "No sequences file found in  $fastaPath. But you are only creating a DB...\n";
          #$$configHash->{$name.'Present'} = 'NO';
        #}
      }else{#If session is loaded then the fasta must stay only in the session folder. No other fasta can be shifted there. Die otherwi$
        if (-e $sessionFolder.'/'.$fastaSeqs) {
          print "Sequences found in your session folder. Checking it...\n";
          $$configHash->{$name.'Present'} = 'YES';
                                #After the name all the fasta is checked to see if it respects the standards
					my $warnings = checkFastaFormat($sessionFolder.'/'.$$configHash->{'fastaSeqs'},$$configHash->{'maxFastaSeqLen'},$$configHash->{'nuclIUPAC'},$$configHash->{'protIUPAC'});
                                        if($warnings > 0){
                                                die "Fasta check failed! The transcriptome you are using have the listed problems ".
                                               	" which can cause stochastic error in BLAST programs execution. ".
                                               	"Please try to correct the problems. Exiting...\n";
                                        }
        }else{
          die "Unable to find ".$$configHash->{'fastaSeqs'}." in $sessionFolder. The program will exit and you can figure out why.".
                    " \nThere are 2 possible reasons: \n\t 1. you written a wrong fasta name in the configuration file.".
                    "\n\t 2. the name in the config file is right but not the folder you chose\n Bye!\n ";
        }
      }

      if ($$configHash->{$name.'Present'} eq 'YES'){

        #Here we control what kind of alphabet has the sequence and store the value in a variable
        $$configHash->{$name.'Alphabet'} = detect_fasta_type($sessionFolder.'/'.$fastaSeqs);
        print "The program detected that your sequences are ";
        if ( ($$configHash->{$name.'Alphabet'} eq 'dna') or ($$configHash->{$name.'Alphabet'} eq 'rna') ){
            print "transcripts\n";
        }else{
            print $$configHash->{$name.'Alphabet'}."\n";
         }
        #Here we count and store the number of sequences in the fasta file
        my $seqsPath = $sessionFolder.'/'.$fastaSeqs;
        my $totSequences = count_sequences($seqsPath); #Extract number of sequences from the query file
        print "Number of sequences: $totSequences";
        $$configHash->{$name.'totSequences'} = $totSequences;
      }
    }
  }else {
    die "The name of file with transcripts needs to have a .fa or .fasta extension. Exiting...\n";
  }
}

=head2 try_exec_command

 Title   : try_exec_command
 Usage   : try_exec_command( -sysCall => is the string that should be repeated
                               );

 Function:  Given in input a command it will try to execute it with system function more than one times.

 Returns : 1 if succeed, -1 otherwise

=cut
sub try_exec_command{
    my $command = shift;

    my $maxTimes = 5;
    my $success = -1;
    my $timesCount = 0;

    while ($success == -1 and $timesCount < $maxTimes){
        if ( (system $command) == 0) {
          $success = 1;
        }
        else{
         if ($? == -1) {
              print "failed to execute: $!\n";
          }
          elsif ($? & 127) {
              printf "child died with signal %d, %s coredump\n",
                  ($? & 127),  ($? & 128) ? 'with' : 'without';
          }
          else {
              printf "child exited with value %d\n", $? >> 8;
              
          }
         $timesCount++;
        }
    }
    return $success;
}

#=head2 build_input_name_from_executed
#
# Title   : build_input_name_from_executed
# Usage   : build_input_name_from_executed(   );
#
# Function: Takes in input the hash with parameters from the sample table
#					and the step in which we are and uses the array steps_array
#					to construct the name depending by the mode
#					
# Returns : a string with the name of the file to be used as input in some program
#=cut
#sub build_input_name_from_executedOLD{
#	my $cfg_hash = shift;
#	my $params = shift;
#	my $step = shift;
#	my $in = shift;
#	
#	my $out = $in;
#	my $stop = 0;
#	for ( my $i = 0; $i < scalar(@steps_array) and $stop == 0; $i++){
#		#If from the database we see that the specific step has been run add its suffix
#		if ( $steps_array[$i] eq $step ) {
#			$stop = 1;
#		}elsif ( $params->{$steps_array[$i]} == 1){
#			$out .= '_'.$steps_array[$i];
#		}
#	}
#	
#	return $out;
#}

=head2 build_input_name_from_executed

 Title   : build_input_name_from_executed
 Usage   : build_input_name_from_executed(   );

 Function: Takes in input the hash with parameters from the sample table
					and the step in which we are and uses the array steps_array
					to construct the name depending by the mode
					
 Returns : a string with the name of the file to be used as input in some program
=cut
sub build_input_name_from_executed{
	my $params = shift;
	my $step = shift;
	my $in = shift;
	my $steps_array = shift;
	
	my $out = $in;
	my $stop = 0;
	for ( my $i = 0; $i < scalar(@$steps_array) and $stop == 0; $i++){
		#If from the database we see that the specific step has been run add its suffix
		if ( $steps_array->[$i] eq $step ) {
			$stop = 1;
		}elsif ( $params->{$steps_array->[$i]} == 1){
			$out .= '_'.$steps_array->[$i];
		}
	}
	return $out;
}


=head2 separate_input_ids

 Title   : separate_input_ids
 Usage   : separate_input_ids(   );

 Function:  given ids in the form 1,2,3 or 1-4,5,6 will separate this ids
						and will return a list separated by comma
 
 Returns : nothing

=cut
sub separate_input_ids{
	my $ids = shift;
	my $sep = shift;
	
	my $final = '';
	
	my @ids = split($sep,$ids);
	#print "I am separating: $ids\n";#DEBUG_CODE
	foreach my $id (@ids){
		if ($id =~ /\-/){
				#print "There is sep with -\n";#DEBUG_CODE
				my @nums = split("-",$id);
				#print "From: ".$nums[0]." to ".$nums[1]."\n";#DEBUG_CODE
				for (my $i = $nums[0]; $i <= $nums[1]; $i++){
						$final .= "$i,";
				}
		}else{
				$final .= "$id,";
		}
	}
	chop($final);
	#print "Returning $final\n";#DEBUG_CODE
	return $final;
}


=head2 try_exec_job

 Title   : try_exec_job
 Usage   : try_exec_command(    $qsub_account => account to use for execution;
																$qsub_queue => queue to use;
																$env_vars =s> variables to pass to subject program
																$program_to_run => program to be run;
																$lnodes => number of nodes needed;
																$ppn => number of cpus needed;
                               );

 Function:  Given in input a command it will try to execute it with system function more than one times.
						
						If the variable qsub_param_for_all=YES then it takes the parameters for the resources
						request from the program_config. This means that all the tasks will ask for the same
						number of resources. Otherwise the suffix of the variable will change with the task name 
						(qc,align, refine, etc..) and the resources will be ask depending by the task 
						from the user_config.
						The following are the parameters for qsub that can be changed
							qsub_mem = 120GB
							qsub_ncpus = 12
							qsub_nodes =
							qsub_select = 1
							
							
 Returns : 1 if succeed, -1 otherwise

=cut
sub try_exec_job{
	my $cfg_hash = shift;
	my $env_vars =shift;
	my $task = shift;
	my $program_path = shift;
	my $job_name = shift;
	my $dependencies = shift;
	my $std_out = shift;
	my $std_err = shift;
	my $log_file = shift;
	
	my $qsub_command;
	#Account to be used to launch job on the cluster
	if (defined $cfg_hash->{'qsub_cmd'} ){
		$qsub_command = $cfg_hash->{'qsub_cmd'};
	}	
	#A string with parameters for the job taken from the program config file
	my $qsub_params = "";
	#Account to be used to launch job on the cluster
	if (defined $cfg_hash->{'qsub_account'} ){
		$qsub_params .= " -A ".$cfg_hash->{'qsub_account'};
	}
	#The queue to use
	if (defined $cfg_hash->{'qsub_queue'} ){
		$qsub_params .= " -q ".$cfg_hash->{'qsub_queue'};
	}
	#The queue to use
	if (defined $cfg_hash->{'qsub_walltime'} ){
		$qsub_params .= " -l walltime=".$cfg_hash->{'qsub_walltime'};
	}
	#Active the restartable job
	if ( $cfg_hash->{'qsub_restartable'} eq 'YES'){
		$qsub_params .= " -r y";
	}
	######Given in input
	#Define the jobname
	if ($job_name ne 'null' ){
		$qsub_params .= " -N ".$job_name;
	}
	#Use dependencies
	if ($dependencies ne 'no_depend'){
		$qsub_params .= " -W depend=afterok:$dependencies ";
	}
	if (defined $cfg_hash->{'qsub_account'} ){
		$qsub_params .= " -W group_list=".$cfg_hash->{'qsub_account'}." ";
	}
	#Define the standard output
	if ($std_out ne 'null' ){
		$qsub_params .= " -o ".$std_out;
	}
	#Define the standard error
	if ($std_err ne 'null' ){
		$qsub_params .= " -e ".$std_err;
	}	
	#From the user configuration file (dependent by program)
	my $qsub_resources = "";
	#Define the resources needed
	my $suff ="";
	if ( $cfg_hash->{'qsub_param_for_all'} eq 'YES' ){
		$suff = $qsub_command;
	}else{
		$suff = $task;
	}
	if (defined $cfg_hash->{$suff.'_select'} or defined $cfg_hash->{$suff.'_cpus'} 
				or defined $cfg_hash->{$suff.'_nodes'} or defined $cfg_hash->{$suff.'_job_memory'}
				or defined $cfg_hash->{$suff.'_ncpus'}){
		$qsub_resources .= " -l ";
	}
	if (defined $cfg_hash->{$suff.'_select'}){
		$qsub_resources .= "select=".$cfg_hash->{$suff.'_select'}.":";
	}
	if (defined $cfg_hash->{$suff.'_ncpus'}){
		$qsub_resources .= "ncpus=".$cfg_hash->{$suff.'_ncpus'}.":";
	}
	if (defined $cfg_hash->{$suff.'_nodes'}){
		$qsub_resources .= "nodes=".$cfg_hash->{$suff.'_nodes'}.":";
	}
	if (defined $cfg_hash->{$suff.'_mem'}){
		$qsub_resources .= "mem=".$cfg_hash->{$suff.'_mem'}.":";
	}			
	
	chop($qsub_resources);
	
	#Add environmental variables
	$qsub_params .= " $qsub_resources  -v $env_vars ";
	my $command = $qsub_command.$qsub_params.$program_path;
	print_and_log( "Executing command: $command\n",$log_file);
	my $qsub_id = `$command`;
	chomp($qsub_id);
	if ($qsub_id ne ''){
		print "Output from qsub: $qsub_id\n";
		#The qsub id should come out with number.host. Hence I remove the host
		$qsub_id =~ s/\..*//;
		#print "qsub_id: $qsub_id\n";#DEBUGCODE
	}else{
		print "ERROR: Unable to start $program_path. Please check error from qsub..\n ";
	}
	return $qsub_id;
	#die "Unable to execute: $command\n";
}



=head2 execute_threads

 Title  : execute_threads
 Usage  : execute_threads( - commands => 'the commands to be executed',
                              );

 Function: for each command it will launch a thread performing that operation
			
 Returns : nothing

=cut	 
sub execute_threads{
  my $commands = shift;#reference to array of commands
  
  my $processes = scalar(@$commands);
  print "Executing $processes commands \n";# I'll write a log in $log.\n"; 
  #Creates an object to fork processes in parallel
  my $pm = new Parallel::ForkManager($processes);

  #You can define a subroutine which is called when a child is terminated. It is called in the parent process.
  #  - pid of the process, which is terminated
  # - exit code of the program
  $pm->run_on_finish(
    sub {
      my($pid,$exit_code) = @_;
      #print "** Just got out of the pool with PID $pid and exit code: $exit_code\n";#DEBUCODE
    }
  );

	foreach my $cmd (@$commands){
    # Forks and returns the pid for the child:
    my $pid = $pm->start and next;
   
    # Here is the parallelized block
    # -----------
    #print "$pid ---> running \n";
    print  "Launching $cmd\n";
    try_exec_command($cmd);
    
    # Terminates the child process
    $pm->finish;
    print "Thread $pid finished. \n";
	}

  $pm->wait_all_children; 
}


=head2 kill_job

 Title   : kill_job
 Usage   : kill_job( 
							- job_id -> the job id to be removed
							);
							
 Function: will kill bill
 
 Returns : nothing

=cut
sub kill_job{
	my $bill = shift;
	
	my $command = "qdel $bill";
	try_exec_command($command) or die "Unable to execute command: $command\n";
	
	print "Job $bill killed!\n";#DEBUGCODE
}

###############################LOG FUNCTIONS#########################################
=head2 print_and_log

 Title   : print_and_log
 Usage   : print_and_log( - string -> the sentence that have to be print_and_log 
											- onlyLog -> a number);

 Function: will print (the string in input always in the log file and on the STDOUT
					if onlyLog is used then the print will be only in the log file
 Returns : nothing

=cut
sub print_and_log{
  my $string = shift;    
  my $logFile = shift; 
  my $onlyLog = shift;
  
  open(LOG, ">>$logFile") or die "ERROR [$!]: Cannot open $logFile! Check permissions.\n";
  if ( defined $onlyLog){
    print LOG $string;
  }else{
    my $STDOUT = *STDOUT;
    my $LOG = *LOG;
    #Prints on both OUT
    for ($LOG, $STDOUT) { print $_ $string; }
  }
  #Close the log
	close(LOG)
}

=head2 log_and_exit

 Title   : log_and_exit
 Usage   : log_and_exit( - string -> the sentence that have to be print in the log

 Function: will print the string and die
 
 Returns : nothing

=cut
sub log_and_exit{
  my $string = shift; 
  my $logFile = shift;     
  
  my $STDOUT = *STDOUT;
  
  open(LOG, ">>$logFile") or die "ERROR [$!]: Cannot open $logFile! Check permissions.\n";
  my $LOG = *LOG;
  #Print on both the log and the STDOUT the error
  for ($LOG, $STDOUT) { print $_ $string; }
  #if ( -d $logFolder){
    ##Moving the log file to the log folder before to exit the program
    #move($workingFolder.'/'.$logFile, $logFolder."/".$logFile) or die "Cannot move $workingFolder/$logFile to $logFolder/$logFile\n";
  #}
  #Close the log
	close(LOG);
  exit;
}


=head2 R_die

 Title : R_die
 Usage : R_die( );

 Function: die with R script and says to see the R log file. It moves the R log file in the log folder.

 Returns : nothing.. it dies..

=cut 
sub R_die{
  my $command = shift;
  my $R_script = shift;
  my $logFolder = shift;
  
  print "The program will die for problems with R. Command: $command\n";
 
  if ( -d $logFolder){
   # print "Trying to move ".$R_plot_script."out in ".$logFolder."/".$R_plot_script."out\n";
    my $RlogName = extract_name($R_script,0);
   #Moving the log file to the log folder before to exit 
    move($RlogName."out", $logFolder."/".$RlogName."out") 
      or die "Cannot move ".$R_script."out in ".$logFolder."/".$R_script."out";
    print "Please check the R log file at $logFolder/".$R_script."out\n";
  }else{
    print "The program tried without succeed to move the log file ".$R_script."out: $logFolder does not exists.\n";
  }
  die;
}  
####################################################################################################



1;

